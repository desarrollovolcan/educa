#!/usr/bin/env php
<?php

declare(strict_types=1);

use GoEduca\Database\Connection;
use GoEduca\Support\Env;

require_once __DIR__ . '/../src/Support/Env.php';
require_once __DIR__ . '/../src/Database/Connection.php';

Env::load(__DIR__ . '/../.env');

$command = $argv[1] ?? null;

if ($command === null) {
    fwrite(STDOUT, "Go Educa CLI\n\nAvailable commands:\n");
    fwrite(STDOUT, "  db:init\n  db:upgrade\n  db:rollback --steps=1\n  db:backup\n");
    exit(0);
}

$basePath = realpath(__DIR__ . '/..');
$migrationsPath = $basePath . '/../database/migrations';
$updatesPath = $basePath . '/../database/updates';
$seedsPath = $basePath . '/../database/seeds/seed.sql';

switch ($command) {
    case 'db:init':
        dbInit($migrationsPath, $seedsPath, $updatesPath);
        break;
    case 'db:upgrade':
        dbUpgrade($migrationsPath, $updatesPath);
        break;
    case 'db:rollback':
        $steps = 1;
        foreach ($argv as $arg) {
            if (str_starts_with($arg, '--steps=')) {
                $steps = (int) str_replace('--steps=', '', $arg);
            }
        }
        dbRollback($migrationsPath, $steps);
        break;
    case 'db:backup':
        dbBackup($basePath);
        break;
    default:
        fwrite(STDERR, "Unknown command: {$command}\n");
        exit(1);
}

function dbInit(string $migrationsPath, string $seedsPath, string $updatesPath): void
{
    $dbName = Env::get('DB_DATABASE', 'goeduca');
    $dbUser = Env::get('DB_USERNAME', 'goeduca');
    $dbPass = Env::get('DB_PASSWORD', 'secret');

    $rootPdo = Connection::rootPdoOrNull();
    if ($rootPdo === null) {
        fwrite(STDERR, "Root connection unavailable; skipping database/user provisioning.\n");
    } else {
        try {
            $dbIdentifier = sprintf('`%s`', str_replace('`', '``', $dbName));
            $userIdentifier = sprintf('%s@%s', $rootPdo->quote($dbUser), $rootPdo->quote('%'));
            $passwordLiteral = $rootPdo->quote($dbPass);

            $rootPdo->exec("CREATE DATABASE IF NOT EXISTS {$dbIdentifier} CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci");
            $rootPdo->exec("CREATE USER IF NOT EXISTS {$userIdentifier} IDENTIFIED BY {$passwordLiteral}");
            $rootPdo->exec("GRANT ALL PRIVILEGES ON {$dbIdentifier}.* TO {$userIdentifier}");
            $rootPdo->exec('FLUSH PRIVILEGES');
        } catch (PDOException $exception) {
            fwrite(STDERR, "Database provisioning failed: {$exception->getMessage()}\n");
        }
    }

    $pdo = Connection::appPdoOrNull();
    if ($pdo === null) {
        fwrite(
            STDERR,
            "Unable to connect with application credentials. Ensure the database exists and credentials are valid.\n"
        );
        exit(1);
    }
    ensureSchemaVersionsTable($pdo);

    $migrations = listMigrations($migrationsPath);
    applyMigrations($pdo, $migrations, $migrationsPath, $updatesPath, true);

    if (file_exists($seedsPath)) {
        $seedSql = file_get_contents($seedsPath);
        if ($seedSql !== false) {
            $pdo->exec($seedSql);
        }
    }

    fwrite(STDOUT, "Database initialized successfully.\n");
}

function dbUpgrade(string $migrationsPath, string $updatesPath): void
{
    $pdo = Connection::appPdo();
    ensureSchemaVersionsTable($pdo);
    $migrations = listMigrations($migrationsPath);
    applyMigrations($pdo, $migrations, $migrationsPath, $updatesPath, false);
    fwrite(STDOUT, "Database upgraded successfully.\n");
}

function dbRollback(string $migrationsPath, int $steps): void
{
    $pdo = Connection::appPdo();
    ensureSchemaVersionsTable($pdo);

    $stmt = $pdo->prepare('SELECT version_name FROM schema_versions ORDER BY applied_at DESC LIMIT :steps');
    $stmt->bindValue(':steps', $steps, PDO::PARAM_INT);
    $stmt->execute();
    $versions = $stmt->fetchAll(PDO::FETCH_COLUMN);

    if ($versions === false || count($versions) === 0) {
        fwrite(STDOUT, "No migrations to rollback.\n");
        return;
    }

    foreach ($versions as $version) {
        $path = $migrationsPath . '/' . $version . '.sql';
        if (!file_exists($path)) {
            fwrite(STDERR, "Migration file not found for rollback: {$path}\n");
            continue;
        }

        $sql = file_get_contents($path);
        if ($sql === false) {
            continue;
        }

        [$upSql, $downSql] = splitMigrationSql($sql);
        if (trim($downSql) === '') {
            fwrite(STDERR, "No DOWN SQL for migration {$version}.\n");
            continue;
        }

        $pdo->exec($downSql);
        $delete = $pdo->prepare('DELETE FROM schema_versions WHERE version_name = :version');
        $delete->execute(['version' => $version]);
        fwrite(STDOUT, "Rolled back {$version}.\n");
    }
}

function dbBackup(string $basePath): void
{
    $dbName = Env::get('DB_DATABASE', 'goeduca');
    $dbUser = Env::get('DB_USERNAME', 'goeduca');
    $dbPass = Env::get('DB_PASSWORD', 'secret');
    $dbHost = Env::get('DB_HOST', '127.0.0.1');
    $dbPort = Env::get('DB_PORT', '3306');

    $backupDir = $basePath . '/../backups';
    if (!is_dir($backupDir)) {
        mkdir($backupDir, 0755, true);
    }

    $timestamp = date('Ymd_His');
    $file = $backupDir . "/{$dbName}_{$timestamp}.sql";

    $command = sprintf(
        'mysqldump --host=%s --port=%s --user=%s --password=%s %s > %s',
        escapeshellarg($dbHost),
        escapeshellarg($dbPort),
        escapeshellarg($dbUser),
        escapeshellarg($dbPass),
        escapeshellarg($dbName),
        escapeshellarg($file)
    );

    system($command, $resultCode);

    if ($resultCode !== 0) {
        fwrite(STDERR, "Backup failed. Ensure mysqldump is available.\n");
        exit(1);
    }

    fwrite(STDOUT, "Backup saved to {$file}.\n");
}

function ensureSchemaVersionsTable(PDO $pdo): void
{
    $pdo->exec(
        'CREATE TABLE IF NOT EXISTS schema_versions (
            version_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
            version_name VARCHAR(255) NOT NULL UNIQUE,
            applied_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
            checksum VARCHAR(64) NOT NULL,
            applied_by VARCHAR(100) NOT NULL
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;'
    );
}

function listMigrations(string $migrationsPath): array
{
    $files = glob($migrationsPath . '/*.sql');
    if ($files === false) {
        return [];
    }

    $migrations = [];
    foreach ($files as $file) {
        $migrations[] = basename($file, '.sql');
    }

    sort($migrations);
    return $migrations;
}

function applyMigrations(PDO $pdo, array $migrations, string $migrationsPath, string $updatesPath, bool $includeSeed): void
{
    $applied = $pdo->query('SELECT version_name FROM schema_versions')->fetchAll(PDO::FETCH_COLUMN);
    if ($applied === false) {
        $applied = [];
    }

    $pending = array_values(array_diff($migrations, $applied));
    if (count($pending) === 0) {
        fwrite(STDOUT, "No pending migrations.\n");
        return;
    }

    $fromVersion = $applied ? end($applied) : 'v0';
    $toVersion = end($pending);

    $updatesSql = '';
    foreach ($pending as $migration) {
        $path = $migrationsPath . '/' . $migration . '.sql';
        $sql = file_get_contents($path);
        if ($sql === false) {
            continue;
        }
        [$upSql] = splitMigrationSql($sql);
        $pdo->exec($upSql);

        $checksum = hash('sha256', $upSql);
        $stmt = $pdo->prepare('INSERT INTO schema_versions (version_name, checksum, applied_by) VALUES (:version, :checksum, :applied_by)');
        $stmt->execute([
            'version' => $migration,
            'checksum' => $checksum,
            'applied_by' => Env::get('DB_USERNAME', 'goeduca'),
        ]);

        $updatesSql .= "-- Migration: {$migration}\n" . $upSql . "\n\n";
    }

    if (!is_dir($updatesPath)) {
        mkdir($updatesPath, 0755, true);
    }

    $timestamp = date('Ymd_His');
    $updateFile = sprintf('%s/update_%s.sql', $updatesPath, $timestamp);
    file_put_contents($updateFile, $updatesSql);

    if ($includeSeed) {
        fwrite(STDOUT, "Seeds applied.\n");
    }
}

function splitMigrationSql(string $sql): array
{
    $parts = preg_split('/^--\s*DOWN\s*$/mi', $sql);
    if ($parts === false) {
        return [$sql, ''];
    }

    $upSql = trim($parts[0]);
    $downSql = $parts[1] ?? '';

    $upSql = preg_replace('/^--\s*UP\s*$/mi', '', $upSql) ?? $upSql;

    return [$upSql, trim($downSql)];
}
